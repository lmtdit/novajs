// Generated by CoffeeScript 1.9.3

/**
* Basic tools
* @date 2014-12-2 15:10:14
* @author pjg <iampjg@gmail.com>
* @link http://pjg.pw
* @version $Id$
 */
var Tools, _, _url, crypto, fs, http, https, key, path, queryStr;

fs = require('fs');

path = require('path');

_url = require("url");

http = require("http");

https = require("https");

queryStr = require("querystring");

crypto = require("crypto");

_ = require("lodash");

Tools = {};

key = "%#12ds)*(shenba_2015";

Tools.md5 = function(text) {
  return crypto.createHash('md5').update(text).digest('hex');
};


/*
 * make dir
 */

Tools.mkdirsSync = function(dirpath, mode) {
  if (fs.existsSync(dirpath)) {
    return true;
  } else {
    if (Tools.mkdirsSync(path.dirname(dirpath), mode)) {
      fs.mkdirSync(dirpath, mode);
      return true;
    }
  }
};


/*
 * make dirs
 */

Tools.mkdirs = function(dirpath, mode, callback) {
  return fs.exists(dirpath, function(exists) {
    if (exists) {
      return callback(exists);
    } else {
      return mkdirs(path.dirname(dirpath), mode, function() {
        return fs.mkdir(dirpath, mode, callback);
      });
    }
  });
};

Tools.getFileSync = function(file, encoding) {
  var _encoding, fileCon, stats;
  _encoding = encoding || 'utf8';
  fileCon = '';
  if (fs.existsSync(file)) {
    stats = fs.statSync(file);
    if (stats.isFile()) {
      fileCon = fs.readFileSync(file, _encoding);
    }
  }
  return fileCon;
};

Tools.getJSONSync = function(file) {
  var string;
  string = fs.readFileSync(file, 'utf8');
  return JSON.parse(string, true);
};

Tools.getUrl = function(url, callback, errback) {
  var HttpType, option, resultData;
  resultData = '';
  option = _url.parse(url);
  HttpType = option.protocol.indexOf('https') > -1 ? https : http;
  return HttpType.get(url, function(res) {
    res.setEncoding('utf8');
    res.on('data', function(data) {
      return resultData += data;
    });
    return res.on('end', function() {
      return callback && callback(resultData);
    });
  }).on('error', function(e) {
    return errback && errback(e.message);
  });
};

Tools.postUrl = function(url, data, headers, callback, errback) {
  var HttpType, option, req, resultData, sendData;
  resultData = '';
  option = _url.parse(url);
  sendData = _.isObject(data) ? queryStr.stringify(data) : data;
  option.method = 'POST';
  option.headers = {
    "Content-Type": 'application/x-www-form-urlencoded',
    "Content-Length": sendData.length
  };
  if (headers) {
    option.headers = _.assign(option.headers, headers);
  }
  HttpType = option.protocol === 'http:' ? http : https;
  req = HttpType.request(option, function(res) {
    res.setEncoding('utf8');
    res.on('data', function(data) {
      return resultData += data;
    });
    return res.on('end', function() {
      return callback && callback(resultData);
    });
  });
  req.on('error', function(e) {
    return errback && errback(e.message);
  });
  req.write(sendData + "\n");
  return req.end();
};

Tools.getJSON = function(url, callback, errback) {
  return Tools.getUrl(url, function(data) {
    var e, json;
    json = null;
    try {
      json = JSON.parse(data);
    } catch (_error) {
      e = _error;
      errback && errback(e);
      return false;
    }
    return callback && callback(json);
  }, errback);
};

Tools.deepDo = function(list, deepFunc, cumulateFunc, callback, deep) {
  deep = deep || 0;
  if (!list[deep]) {
    if (callback) {
      callback();
    }
    return;
  }
  return deepFunc(list[deep], function(result) {
    if (cumulateFunc) {
      cumulateFunc(result, list[deep], deep);
    }
    if (deep + 1 < list.length) {
      return Tools.deepDo(list, deepFunc, cumulateFunc, callback, deep + 1);
    } else {
      if (callback) {
        return callback();
      }
    }
  });
};

Tools.exec = function(command, callback) {
  return exec(command, function(error, stdout, stderr) {
    if (stdout) {
      console.log('exec stdout: ' + stdout);
    }
    if (stderr) {
      console.log('exec stderr: ' + stderr);
    }
    if (error) {
      console.log('exec error: ' + error);
    }
    if (callback) {
      return callback();
    }
  });
};

Tools.encrypt = function(str, secret) {
  var _secret, cipher, enc;
  _secret = secret || key;
  cipher = crypto.createCipher('aes192', _secret);
  enc = cipher.update(str, 'utf8', 'hex');
  enc += cipher.final('hex');
  return enc;
};

Tools.decrypt = function(str, secret) {
  var _secret, dec, decipher;
  _secret = secret || key;
  decipher = crypto.createDecipher('aes192', _secret);
  dec = decipher.update(str, 'hex', 'utf8');
  dec += decipher.final('utf8');
  return dec;
};

module.exports = Tools;
